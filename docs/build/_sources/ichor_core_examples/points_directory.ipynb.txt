{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# `PointsDirectory` - A class used to encapsulate all calculations for many geometries (of a dataset)\n",
    "\n",
    "The `ichor.core.files.PointsDirectory` class can be used to easily work with thousands of files which are generated when getting Gaussian, AIMAll, etc. calculations for many geometries.\n",
    "\n",
    "The general structure of a `PointsDirectory`-like directory is like so:\n",
    "\n",
    "```\n",
    ".\n",
    "|--- SYSTEM0001\n",
    "|   |--- SYSTEM0001_atomicfiles\n",
    "|   |   |--- h2.int\n",
    "|   |   |--- h3.int\n",
    "|   |   |--- o1.int\n",
    "|   |--- SYSTEM0001.gjf\n",
    "|   |--- SYSTEM0001.wfn\n",
    "|--- SYSTEM0002\n",
    "|   |--- SYSTEM0002_atomicfiles\n",
    "|   |   |--- h2.int\n",
    "|   |   |--- h3.int\n",
    "|   |   |--- o1.int\n",
    "|   |--- SYSTEM0002.gjf\n",
    "|   |--- SYSTEM0002.wfn\n",
    "...\n",
    "...\n",
    "...\n",
    "```\n",
    "\n",
    "Essentially, `PointsDirectory` is a classed that is used to parse a directory contains many sub-directories. Each sub-directory (e.g. `SYSTEM0001`, `SYSTEM0002`) contains all relevant calculations for **one** geometry. Each of the *sub-directories* can be individually read in as a `ichor.core.files.PointDirectory` instance (note that there is no *s* in this case.)\n",
    "\n",
    "This class makes it easy to access calculations for many geometries very easily. For example, it can be used if you want to get the `.wfn` energy of all geometries."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## `PointDirectory` strucutre\n",
    "\n",
    "The `PointDirectory` class encapsulates a directory, containing all relevant calculations for **one** geometry. It subclasses from `ichor.core.files.directory.AnnotatedDirectory`. This gives us the ability to define *class* variables, which are of specific file types. Then the `AnnotatedDirectory._parse` method is what parses all files in the directory. The extensions of the files determine what the file type, and thus the class which is going to be used to parse the file."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Obtaining Gaussian results"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Obtaining total energy from `PointsDirectory`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WATER_MONOMER0000.pointdir -76.421710687455\n",
      "WATER_MONOMER0001.pointdir -76.429947804\n",
      "WATER_MONOMER0002.pointdir -76.430599107417\n",
      "WATER_MONOMER0003.pointdir -76.42948849797\n"
     ]
    }
   ],
   "source": [
    "from ichor.core.files import PointsDirectory\n",
    "\n",
    "# PointsDirectory(\"path_to_directory_with_wfn_and_int_files\")\n",
    "points_dir = PointsDirectory(\"../../../example_files/example_points_directory/WATER_MONOMER.pointsdir\")\n",
    "\n",
    "for point_directory in points_dir:\n",
    "\n",
    "    print(point_directory.name, point_directory.wfn.total_energy)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Accessing IQA energy for a specific atom"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WATER_MONOMER0000.pointdir -75.446714709\n",
      "WATER_MONOMER0001.pointdir -75.453164031\n",
      "WATER_MONOMER0002.pointdir -75.453749708\n",
      "WATER_MONOMER0003.pointdir -75.453284702\n"
     ]
    }
   ],
   "source": [
    "for point_directory in points_dir:\n",
    "\n",
    "    print(point_directory.name, point_directory.ints[\"O1\"].iqa)\n",
    "\n",
    "# note that this is for A A'"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Accessing Mulipole Moments"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WATER_MONOMER0000.pointdir {'q00': -1.051921199, 'q10': -0.020042356378, 'q11c': 0.0018273275449, 'q11s': -0.20706556929, 'q20': -0.037266216811, 'q21c': -0.79780613831, 'q21s': 0.013146921148, 'q22c': -0.19595266005, 'q22s': 0.078488472227, 'q30': 0.043015515207, 'q31c': -0.053621704828, 'q31s': 0.21644282193, 'q32c': -0.029607236961, 'q32s': -0.89197505111, 'q33c': -0.053969314597, 'q33s': 0.16211677693, 'q40': -1.4545843935, 'q41c': 0.91783517331, 'q41s': 0.17650015949, 'q42c': -0.73112185714, 'q42s': -0.3293114897, 'q43c': 2.8344280941, 'q43s': -0.16267842746, 'q44c': -1.3853362266, 'q44s': 0.089771195512, 'q50': -0.24411738335, 'q51c': 0.48960856702, 'q51s': -1.5472642317, 'q52c': -0.040094542612, 'q52s': 0.98097072569, 'q53c': 0.72718022845, 'q53s': -1.1988409017, 'q54c': -0.47766441277, 'q54s': 2.0753064137, 'q55c': -0.29405113415, 'q55s': -1.6430303594}\n",
      "WATER_MONOMER0001.pointdir {'q00': -1.1248310833, 'q10': -0.15773618224, 'q11c': 0.081543820356, 'q11s': 0.12130191092, 'q20': -0.12606180318, 'q21c': 0.19139555969, 'q21s': -0.528487624, 'q22c': 0.54627966503, 'q22s': -0.078510757285, 'q30': -0.27889785637, 'q31c': 0.49213687845, 'q31s': -0.3074017347, 'q32c': 0.14764509944, 'q32s': -0.24727703379, 'q33c': -0.44944367966, 'q33s': -0.35435058603, 'q40': -0.48581728297, 'q41c': 1.5494543387, 'q41s': -0.23351555403, 'q42c': -0.86875233643, 'q42s': -1.853314432, 'q43c': -1.8063689406, 'q43s': -1.1998626773, 'q44c': 0.48732628951, 'q44s': 1.3828550511, 'q50': 0.4495412122, 'q51c': 0.31877779684, 'q51s': -0.024332972891, 'q52c': -1.476162947, 'q52s': -2.119742167, 'q53c': -1.5055751323, 'q53s': 0.18416072712, 'q54c': 0.45591672771, 'q54s': 2.1945711652, 'q55c': 0.03684630334, 'q55s': -1.3214124663}\n",
      "WATER_MONOMER0002.pointdir {'q00': -1.1395301182, 'q10': 0.1170316343, 'q11c': 0.12707113118, 'q11s': 0.14319062627, 'q20': 0.035370307734, 'q21c': -0.42415679932, 'q21s': 0.49791338765, 'q22c': 0.37603023988, 'q22s': 0.20445186908, 'q30': -0.15737553444, 'q31c': 0.45818443084, 'q31s': -0.35883958802, 'q32c': 0.3480880684, 'q32s': 0.20971032944, 'q33c': -0.29423125466, 'q33s': -0.34625176326, 'q40': 0.41096573978, 'q41c': 0.09307943713, 'q41s': 1.5410113059, 'q42c': -2.179742611, 'q42s': -1.5590824961, 'q43c': 0.35883654798, 'q43s': -0.88871603233, 'q44c': 0.43934126428, 'q44s': 1.7461938373, 'q50': 1.0996389779, 'q51c': -1.262699744, 'q51s': -1.3852909494, 'q52c': 1.560792331, 'q52s': 0.24419844412, 'q53c': -0.37471724152, 'q53s': 2.5132383079, 'q54c': -0.95964885508, 'q54s': -0.26895872429, 'q55c': 0.55394494551, 'q55s': -1.8680975711}\n",
      "WATER_MONOMER0003.pointdir {'q00': -1.1261722464, 'q10': 0.11200768361, 'q11c': 0.19713726623, 'q11s': -0.046368083336, 'q20': 0.25960435715, 'q21c': -0.159889789, 'q21s': -0.51517986412, 'q22c': 0.49258123822, 'q22s': 0.087179927499, 'q30': -0.4214583255, 'q31c': 0.024210442018, 'q31s': 0.44866570921, 'q32c': 0.31042203091, 'q32s': 0.23745156258, 'q33c': -0.37812439877, 'q33s': -0.13095025897, 'q40': 0.88553589917, 'q41c': 1.9512466748, 'q41s': -1.4646293031, 'q42c': -1.3890087525, 'q42s': -1.1724735472, 'q43c': -1.3146772524, 'q43s': -0.23121743344, 'q44c': 1.278074295, 'q44s': 0.73371421822, 'q50': 1.1218634504, 'q51c': -2.2221116073, 'q51s': 1.0854260589, 'q52c': -0.70009846634, 'q52s': 1.5789483953, 'q53c': 2.0156858127, 'q53s': 0.35708799616, 'q54c': 1.2709617017, 'q54s': -0.46441127444, 'q55c': -1.2724101051, 'q55s': -0.93923967921}\n"
     ]
    }
   ],
   "source": [
    "for point_directory in points_dir:\n",
    "\n",
    "    print(point_directory.name, point_directory.ints[\"O1\"].global_spherical_multipoles)\n",
    "\n",
    "# note these are not rotated"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Converting to SQLite3 database\n",
    "\n",
    "Reading thousands of files every time is very time consuming (especially on hard drives), so it is much more efficient to read the data once and store it in a database. `ichor` has SQLite3 support implemented, meaning a `PointsDirecotry` can be readily converted to an SQLite3 database. **NOTE: ONLY RAW DATA FROM CALCULATIONS IS STORED IN THE DATABSE. NO POSTPROCESSING IS DONE. ANY POSTPROCESSING MUST BE DONE AT A LATER STEP (e.g. rotating multipole moments).**\n",
    "\n",
    "Code snipped to produce database:\n",
    "\n",
    "```python\n",
    "\n",
    "from ichor.core.files import PointsDirectory\n",
    "\n",
    "pd = PointsDirectory(\"points_directory_path\")\n",
    "pd.write_to_sqlite3_database()\n",
    "```\n",
    "\n",
    "**Note 1: It takes a while to read all files, so this should be submitted on compute.**\n",
    "\n",
    "**Note 2: If the dataset is large and split into many `PointsDirectory`-like directories, then you can do**\n",
    "\n",
    "```python\n",
    "from ichor.core.files import PointsDirectory\n",
    "from pathlib import Path\n",
    "\n",
    "parent_dir = Path(\"parent_dir\")\n",
    "\n",
    "for d in parent_dir.iterdir():\n",
    "\n",
    "    pd = PointsDirectory(\"points_directory_path\")\n",
    "    pd.write_to_sqlite3_database(\"large_database.db\")\n",
    "```\n",
    "\n",
    "where all the information will be stored into one database."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## SQLite Database Schema Diagram\n",
    "\n",
    "The following is that the schema diagram looks like for the table currently. The image was made with DBVisualizer. Note that these **all** fields might not be populated if the database. That depends on the raw data that is present in the `PointsDirectory`. For example, if only Gaussian are ran, then the AIMAll-related data will be missing from the database.\n",
    "\n",
    "Below is a diagram of the SQLite3 Database, made with DbVisualizer\n",
    "![alt text](../../../example_files/sql_database_schema.svg \"SQLite3 Schema\")"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generating CSV files with Features from SQLite3 Database\n",
    "\n",
    "CSV files containing (ALF) features and relevant outputs can be generated from an SQLite3 database like so:\n",
    "\n",
    "```python\n",
    "from ichor.core.database.sql.query_database import (\n",
    "    get_alf_from_first_db_geometry,\n",
    "    write_processed_data_for_atoms_parallel,\n",
    "    write_processed_data_for_atoms\n",
    ")\n",
    "\n",
    "db_path = \"DATABASE_PATH\"\n",
    "\n",
    "# note that you can also define an ALF manually as well\n",
    "# or get it from some other molecular geometry\n",
    "# that contains the same atom sequencing as in the database\n",
    "alf = get_alf_from_first_db_geometry(db_path)\n",
    "\n",
    "# note that this will write files out in parallel\n",
    "# use write_processed_data_for_atoms for serial\n",
    "\n",
    "write_processed_data_for_atoms_parallel(\n",
    "    db_path,\n",
    "    alf,\n",
    "    ncores=4,\n",
    "    calc_multipoles=True, # rotates multipoles using C matrix\n",
    "    calc_forces=False, # calculates ALF forces using Wilson B matrix\n",
    ")\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ichor_docs",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
